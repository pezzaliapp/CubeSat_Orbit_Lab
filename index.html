<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CubeSat Orbit Lab — Standalone + Ombra & Parallax</title>
<style>
:root{
  --bg:#050a1e; --bg2:#0a1233; --ink:#eaf1ff; --muted:#99add6;
  --line:#1b2a66; --accent:#8b5cf6; --glow:#2dd4bf;
}
*{box-sizing:border-box} html,body{height:100%}
body{
  margin:0; font:15px/1.6 system-ui, -apple-system, Segoe UI, Roboto, Arial;
  color:var(--ink);
  background: radial-gradient(1200px 600px at 50% -20%, #121b46 15%, transparent 60%),
              linear-gradient(180deg, var(--bg) 0%, var(--bg2) 100%);
}
header{
  display:flex; justify-content:space-between; align-items:center;
  padding:12px 10px; border-bottom:1px solid var(--line);
  position:sticky; top:0; background:#081133cc; backdrop-filter:blur(8px); z-index:10;
}
header::after{
  content:""; position:absolute; left:0; right:0; bottom:-1px; height:2px;
  background:linear-gradient(90deg, transparent, var(--accent), var(--glow), transparent);
  filter:blur(.6px); opacity:.8; animation:flow 6s linear infinite;
}
@keyframes flow{0%{background-position:-200px 0}100%{background-position:200px 0}}
h1{font-size:16px; margin:0}
nav button{
  border:1px solid var(--line); background:#0f1837; color:var(--ink);
  padding:8px 12px; border-radius:12px; cursor:pointer; font-weight:700;
  transition:transform .12s, box-shadow .2s, background .3s, border-color .2s;
  margin-left:6px;
}
nav button.primary{background:linear-gradient(180deg,#24d3ae,#1fb58f); color:#051813; border:none}
nav button.primary:hover{transform:translateY(-1px); box-shadow:0 10px 24px rgba(33,200,166,.25)}
nav button.ghost:hover{border-color:#3a4aa0; background:#111d47}

main{max-width:1100px; margin:0 auto; padding:14px}
.canvas-wrap{
  position:relative; border:1px solid var(--line); border-radius:18px; overflow:hidden;
  background: radial-gradient(900px 500px at 50% 10%, #0d1433 10%, #0a0f2a 70%);
  box-shadow:0 30px 60px rgba(0,0,0,.35), 0 0 0 1px #0c183f inset;
}
canvas{display:block; width:100%; height:auto}
.hud{
  position:absolute; left:10px; top:10px; font:12px/1.2 ui-monospace, Menlo, Consolas, monospace;
  color:#cfe2ff; text-shadow:0 1px 0 #000;
  background:#0a0f2acc; padding:8px 10px; border-radius:10px; border:1px solid #1a2355;
}
.controls{
  display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
  gap:14px; margin-top:14px;
}
.controls .group{background:linear-gradient(180deg,#0f1742,#0a102f); border:1px solid var(--line); border-radius:14px; padding:12px}
.controls label{display:block; font-size:13px; color:var(--muted); margin-bottom:8px}
.controls input[type=range]{width:100%}
.controls select, .controls input[type=range]{margin-top:6px}
.controls .toggles{display:flex; gap:16px; flex-wrap:wrap}
footer{padding:20px; text-align:center; color:var(--muted)}
.small{font-size:12px; color:var(--muted)}
.badge{display:inline-block; margin-left:8px; padding:2px 8px; border-radius:999px; background:#14204e; color:#a7b7ef; font:700 11px/1 ui-monospace}
</style>
</head>
<body>
<header>
  <h1>CubeSat Orbit Lab <span class="badge">ombra+parallax</span></h1>
  <nav>
    <button id="btnPlay" class="primary">PLAY</button>
    <button id="btnPause" class="ghost">PAUSA</button>
    <button id="btnReset" class="ghost">RESET</button>
  </nav>
</header>

<main>
  <section class="canvas-wrap">
    <canvas id="view" width="960" height="540" aria-label="Simulazione orbita CubeSat"></canvas>
    <div class="hud" id="hud"></div>
  </section>

  <section class="controls">
    <div class="group">
      <label>Scenario
        <select id="scenario">
          <option value="launch">Lancio → Inserimento in orbita</option>
          <option value="leo">LEO Circolare 400 km</option>
          <option value="ellipse">Ellittica 300 × 800 km</option>
          <option value="gto">GTO semplificata</option>
        </select>
      </label>
    </div>

    <div class="group">
      <label>Altitudine Perigeo (km)
        <input id="perigee" type="range" min="180" max="2000" step="10" value="400">
        <span id="perigeeVal">400</span>
      </label>
      <label>Altitudine Apogeo (km)
        <input id="apogee" type="range" min="180" max="36000" step="10" value="400">
        <span id="apogeeVal">400</span>
      </label>
    </div>

    <div class="group">
      <label>Inclinazione i (°)
        <input id="incl" type="range" min="0" max="98" step="1" value="51">
        <span id="inclVal">51</span>
      </label>
      <label>RAAN Ω (°)
        <input id="raan" type="range" min="0" max="360" step="1" value="0">
        <span id="raanVal">0</span>
      </label>
      <label>Argomento del perigeo ω (°)
        <input id="argp" type="range" min="0" max="360" step="1" value="0">
        <span id="argpVal">0</span>
      </label>
      <label>Anomalia media M₀ (°)
        <input id="m0" type="range" min="0" max="360" step="1" value="0">
        <span id="m0Val">0</span>
      </label>
    </div>

    <div class="group">
      <label>Velocità simulazione
        <input id="timescale" type="range" min="0.1" max="120" step="0.1" value="5">
        <span id="timescaleVal">5×</span>
      </label>
      <label>Trail
        <input id="trail" type="range" min="0" max="2000" step="10" value="600">
        <span id="trailVal">600</span>
      </label>
    </div>

    <div class="group toggles">
      <label><input type="checkbox" id="showAxes" checked> Assi</label>
      <label><input type="checkbox" id="showOrbit" checked> Orbita</label>
      <label><input type="checkbox" id="atmo" checked> Atmosfera</label>
      <label><input type="checkbox" id="shadow" checked> Ombra Terra</label>
    </div>
  </section>

  <p class="small">Standalone minimo, senza service worker o manifest. Ora con ombra (umbra/penumbra) e stelle in parallax + tilt terrestre 23.44°.</p>
</main>

<footer>© 2025 — MIT</footer>

<script>
(function(){
  'use strict';
  // === Costanti fisiche
  const R_EARTH = 6371e3;
  const MU = 3.986004418e14;
  const OBLIQUITY = 23.44 * Math.PI/180; // tilt asse terrestre

  // === Canvas / stato
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d');
  let W = canvas.width, H = canvas.height, cx=W/2, cy=H/2;

  let running = false, t = 0, timescale = 5, trailMax = 600, trail = [];

  let perigeeAlt=400e3, apogeeAlt=400e3, inclDeg=51, raanDeg=0, argpDeg=0, m0Deg=0;
  let showAxes=true, showOrbit=true, showAtmo=true, showShadow=true;

  // Camera
  const cam = { r: 2.8*R_EARTH, theta:-0.8, phi:0.9, fov:900, target:{x:0,y:0,z:0} };

  // Utils
  const clamp=(v,min,max)=>v<min?min:(v>max?max:v);
  const toRad=d=>d*Math.PI/180;
  const V=(x,y,z)=>({x,y,z});
  const add=(a,b)=>V(a.x+b.x,a.y+b.y,a.z+b.z);
  const sub=(a,b)=>V(a.x-b.x,a.y-b.y,a.z-b.z);
  const dot=(a,b)=>a.x*b.x+a.y*b.y+a.z*b.z;
  const mul=(a,s)=>V(a.x*s,a.y*s,a.z*s);
  const nrm=a=>{const n=Math.hypot(a.x,a.y,a.z); return n?mul(a,1/n):V(0,0,0);};
  const crs=(a,b)=>V(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);
  function sph(r,th,ph){ return V(r*Math.cos(ph)*Math.cos(th), r*Math.sin(ph), r*Math.cos(ph)*Math.sin(th)); }

  function worldToScreen(p){
    const camPos = sph(cam.r, cam.theta, cam.phi);
    const fwd = nrm(sub(cam.target, camPos));
    const right = nrm(crs(fwd, V(0,1,0)));
    const up = nrm(crs(right, fwd));
    const rel = sub(p, camPos);
    const x = rel.x*right.x + rel.y*right.y + rel.z*right.z;
    const y = rel.x*up.x    + rel.y*up.y    + rel.z*up.z;
    const z = rel.x*fwd.x   + rel.y*fwd.y   + rel.z*fwd.z;
    const s = cam.fov / Math.max(1e-6, (cam.fov + z));
    return {x: cx + x*s, y: cy - y*s, z};
  }
  function projectRadius(r){
    const a = worldToScreen(V(r,0,0)), b = worldToScreen(V(0,0,0));
    return Math.hypot(a.x-b.x, a.y-b.y);
  }

  // Keplero: elementi → posizione
  function elementsToState(a,e,i,raan,argp,M0,tt){
    const n = Math.sqrt(MU/Math.pow(a,3));
    const M = (M0 + n*tt) % (2*Math.PI);
    let E = M;
    for(let k=0;k<8;k++){
      const f = E - e*Math.sin(E) - M, fp = 1 - e*Math.cos(E);
      E -= f/fp;
    }
    const cosE=Math.cos(E), sinE=Math.sin(E);
    const nu = Math.atan2(Math.sqrt(1-e*e)*sinE, cosE - e);
    const r  = a*(1 - e*cosE);
    const xpf = r*Math.cos(nu), ypf = r*Math.sin(nu);
    const cO=Math.cos(raan), sO=Math.sin(raan), ci=Math.cos(i), si=Math.sin(i);
    const co=Math.cos(argp), so=Math.sin(argp);
    const x=(cO*co - sO*so*ci)*xpf + (-cO*so - sO*co*ci)*ypf;
    const y=(so*si)*xpf + (co*si)*ypf;
    const z=(sO*co + cO*so*ci)*xpf + (-sO*so + cO*co*ci)*ypf;
    return V(x,y,z);
  }

  // === Sole con stagionalità (declinazione varia tra ±ε)
  function sunDirection(timeSec){
    const season = timeSec / (200 * Math.PI); // velocità simbolica, lenta
    const alpha = season;                      // ascensione retta
    const delta = OBLIQUITY * Math.sin(season); // declinazione
    const c = Math.cos(delta), s = Math.sin(delta);
    // unit vector in frame equatoriale (x verso AR=0, z verso AR=90°)
    return nrm(V(c*Math.cos(alpha), s, c*Math.sin(alpha)));
  }

  // Ombra (eclissi) — test cilindrico: dentro ombra se dietro la Terra e vicino all'asse
  function inUmbra(p, sDir){
    const d = dot(p, sDir);
    if (d > 0) return false; // lato Sole
    const perp = Math.sqrt(dot(p,p) - d*d);
    return perp < R_EARTH;
  }

  // === Stelle parallax (3 strati)
  const stars = (function seedStars(){
    const rng=(i)=>{ let x = i*1664525 + 1013904223; x ^= x<<13; x ^= x>>17; x ^= x<<5; return Math.abs(x); };
    const layers=[];
    const counts=[120,80,40]; // far, mid, near
    for(let L=0; L<3; L++){
      const arr=[];
      for(let i=0;i<counts[L];i++){
        const rx = rng(i+L*997)%10000/10000;
        const ry = rng(i+L*233)%10000/10000;
        arr.push({x:rx, y:ry});
      }
      layers.push(arr);
    }
    return layers;
  })();

  function drawStars(now){
    // Parallax: offset in base a cam.theta/phi e al layer
    const par=[0.2, 0.5, 1.0];
    ctx.save();
    for(let L=0;L<3;L++){
      ctx.globalAlpha = 0.55 + 0.15*L;
      const k = par[L];
      for(const s of stars[L]){
        const x = ((s.x*W + k*cam.theta*90) % W + W) % W;
        const y = ((s.y*H + k*cam.phi*60)   % H + H) % H;
        const tw = (Math.sin(now*0.001 + (s.x+s.y)*50)*0.5+0.5)*0.6 + 0.2 + 0.1*L;
        ctx.fillStyle = `rgba(255,255,255,${tw.toFixed(3)})`;
        ctx.fillRect(x,y,1,1);
      }
    }
    ctx.restore();
  }

  // Terra + terminatore orientato con sDir (approssimazione 2D)
  function drawEarth(sDir){
    const R = projectRadius(R_EARTH);
    const c = worldToScreen(V(0,0,0));

    // Ombra/terminatore: proiettiamo la direzione del sole su schermo
    if (showShadow){
      const s2 = worldToScreen(add(V(0,0,0), mul(sDir, R_EARTH)));
      const vx = c.x - (s2.x - c.x), vy = c.y - (s2.y - c.y); // punto "notte" opposto al Sole
      const dx = vx - c.x, dy = vy - c.y;
      const shift = 0.35; // quanto spostare il centro del gradiente verso la notte
      const gx = c.x + dx*shift, gy = c.y + dy*shift;

      // penombra esterna
      const pen = ctx.createRadialGradient(gx, gy, R*0.9, c.x, c.y, R*1.15);
      pen.addColorStop(0, "rgba(0,0,0,0.0)");
      pen.addColorStop(1, "rgba(0,0,0,0.18)");
      ctx.fillStyle = pen; ctx.beginPath(); ctx.arc(c.x,c.y,R*1.15,0,Math.PI*2); ctx.fill();

      // night side
      const night = ctx.createRadialGradient(gx, gy, R*0.2, c.x, c.y, R*1.05);
      night.addColorStop(0, "rgba(0,0,0,0.0)");
      night.addColorStop(1, "rgba(0,0,0,0.48)");
      ctx.fillStyle = night; ctx.beginPath(); ctx.arc(c.x,c.y,R,0,Math.PI*2); ctx.fill();
    }

    // globo
    const sea = ctx.createRadialGradient(c.x-0.3*R, c.y-0.35*R, R*0.2, c.x, c.y, R*1.1);
    sea.addColorStop(0,"#2a6fdb"); sea.addColorStop(1,"#0a1d47");
    ctx.fillStyle=sea; ctx.beginPath(); ctx.arc(c.x,c.y,R,0,Math.PI*2); ctx.fill();

    if (showAtmo){
      const Ra = R*1.04;
      const a = ctx.createRadialGradient(c.x, c.y, R*0.95, c.x, c.y, Ra);
      a.addColorStop(0, "rgba(120,200,255,.05)"); a.addColorStop(1, "rgba(120,200,255,0)");
      ctx.fillStyle=a; ctx.beginPath(); ctx.arc(c.x,c.y,Ra,0,Math.PI*2); ctx.fill();
    }
    if (showAxes){
      ctx.strokeStyle="rgba(255,255,255,.2)"; ctx.lineWidth=1; ctx.beginPath();
      const A=[V(R_EARTH*1.3,0,0),V(-R_EARTH*1.3,0,0),V(0,R_EARTH*1.3,0),V(0,-R_EARTH*1.3,0),V(0,0,R_EARTH*1.3),V(0,0,-R_EARTH*1.3)];
      for(let i=0;i<A.length;i+=2){const a=worldToScreen(A[i]), b=worldToScreen(A[i+1]); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y);}
      ctx.stroke();
    }
  }

  function drawOrbitPath(points){
    if (!showOrbit || points.length<2) return;
    ctx.strokeStyle="rgba(96,165,250,.85)"; ctx.lineWidth=1.6; ctx.beginPath();
    let s=worldToScreen(points[0]); ctx.moveTo(s.x,s.y);
    for(let i=1;i<points.length;i++){ s=worldToScreen(points[i]); ctx.lineTo(s.x,s.y); }
    ctx.stroke();
  }
  function drawCubeSat(p, eclipsed){
    const s = worldToScreen(p);
    const size = clamp(8 + 1200/(1 + s.z + 1e-6), 2, 14);
    ctx.fillStyle = eclipsed? "rgba(234,241,255,0.6)" : "#eaf1ff";
    ctx.strokeStyle="rgba(0,0,0,.25)"; ctx.lineWidth=1;
    ctx.beginPath(); ctx.rect(s.x-size/2, s.y-size/2, size, size); ctx.fill(); ctx.stroke();
    ctx.fillStyle = eclipsed? "rgba(96,165,250,0.5)" : "#60a5fa";
    ctx.fillRect(s.x - size*1.9, s.y - size*0.3, size*0.7, size*0.6);
    ctx.fillRect(s.x + size*1.2, s.y - size*0.3, size*0.7, size*0.6);
  }

  // HUD
  const hud = document.getElementById('hud');
  const updateHUD = (a,e,alt,sd)=>{
    // sd: frazione di luce (1=sole, 0=eclissi netta)
    hud.textContent = `t=${t.toFixed(1)}s | alt=${(alt/1000).toFixed(0)}km | a=${(a/1000).toFixed(0)}km | e=${e.toFixed(3)} | i=${inclDeg.toFixed(1)}° | Ω=${raanDeg|0}° | ω=${argpDeg|0}° | M₀=${m0Deg|0}° | luce=${(sd*100).toFixed(0)}%`;
  };

  // UI
  const el = id=>document.getElementById(id);
  const S = {
    per: el('perigee'), apo: el('apogee'), incl: el('incl'), raan: el('raan'),
    argp: el('argp'), m0: el('m0'), ts: el('timescale'), trail: el('trail'),
    scenario: el('scenario')
  };
  const Vals = {
    per: el('perigeeVal'), apo: el('apogeeVal'), incl: el('inclVal'), raan: el('raanVal'),
    argp: el('argpVal'), m0: el('m0Val'), ts: el('timescaleVal'), trail: el('trailVal')
  };
  showAxes = el('showAxes').checked; el('showAxes').onchange = e=>showAxes=e.target.checked;
  showOrbit= el('showOrbit').checked; el('showOrbit').onchange= e=>showOrbit=e.target.checked;
  showAtmo = el('atmo').checked;     el('atmo').onchange     = e=>showAtmo=e.target.checked;
  showShadow=el('shadow').checked;   el('shadow').onchange   = e=>showShadow=e.target.checked;

  function syncUI(){
    perigeeAlt = +S.per.value*1000;   Vals.per.textContent = (perigeeAlt/1000).toFixed(0);
    apogeeAlt  = +S.apo.value*1000;   Vals.apo.textContent = (apogeeAlt/1000).toFixed(0);
    inclDeg    = +S.incl.value;       Vals.incl.textContent= inclDeg.toFixed(0);
    raanDeg    = +S.raan.value;       Vals.raan.textContent= raanDeg.toFixed(0);
    argpDeg    = +S.argp.value;       Vals.argp.textContent= argpDeg.toFixed(0);
    m0Deg      = +S.m0.value;         Vals.m0.textContent  = m0Deg.toFixed(0);
    timescale  = +S.ts.value;         Vals.ts.textContent  = timescale.toFixed(1)+'×';
    trailMax   = +S.trail.value;      Vals.trail.textContent = trailMax.toFixed(0);
    trail = [];
  }
  S.per.oninput=S.apo.oninput=S.incl.oninput=S.raan.oninput=S.argp.oninput=S.m0.oninput=S.ts.oninput=S.trail.oninput=syncUI;

  S.scenario.onchange = ()=>{
    const v=S.scenario.value;
    if (v==='launch'){ S.per.value=200; S.apo.value=400; S.incl.value=51; S.raan.value=0; S.argp.value=0; S.m0.value=0; S.ts.value=3; S.trail.value=400; }
    else if (v==='leo'){ S.per.value=400; S.apo.value=400; S.incl.value=51; S.raan.value=0; S.argp.value=0; S.m0.value=0; S.ts.value=5; S.trail.value=800; }
    else if (v==='ellipse'){ S.per.value=300; S.apo.value=800; S.incl.value=63; S.raan.value=90; S.argp.value=30; S.m0.value=0; S.ts.value=6; S.trail.value=1000; }
    else if (v==='gto'){ S.per.value=250; S.apo.value=35786; S.incl.value=27; S.raan.value=20; S.argp.value=180; S.m0.value=0; S.ts.value=30; S.trail.value=2000; }
    syncUI();
  };

  el('btnPlay').onclick = ()=>running=true;
  el('btnPause').onclick= ()=>running=false;
  el('btnReset').onclick= ()=>{ t=0; trail=[]; };

  // Elementi
  function deriveElements(){
    const rp = R_EARTH + perigeeAlt, ra = R_EARTH + apogeeAlt;
    const a = 0.5*(rp+ra), e = (ra - rp)/(ra + rp);
    return { a, e, i:toRad(inclDeg), raan:toRad(raanDeg), argp:toRad(argpDeg), M0:toRad(m0Deg) };
  }
  function simulateLaunch(dt, el){
    t += dt;
    const k = Math.max(0, Math.min(1, t/120));
    return elementsToState(el.a, el.e*k, el.i*k, el.raan*k, el.argp*k, el.M0*k, t);
  }

  // Loop
  let last = performance.now();
  function loop(now){
    requestAnimationFrame(loop);
    let dt = (now - last)/1000; last = now;
    dt = Math.min(dt, 0.05);

    const el = deriveElements();
    let pos;
    if (S.scenario.value==='launch'){
      pos = simulateLaunch(dt*timescale, el);
    } else {
      if (running) t += dt*timescale;
      pos = elementsToState(el.a, el.e, el.i, el.raan, el.argp, el.M0, t);
    }

    if (running){ trail.push(pos); if (trail.length>trailMax) trail.shift(); }
    cam.theta += 0.03*dt; cam.phi = 0.9 + 0.15*Math.sin(now*0.0005);

    const sDir = sunDirection(t);           // direzione Sole con stagionalità
    const eclipsed = inUmbra(pos, sDir);    // eclissi sì/no
    const alt = Math.hypot(pos.x,pos.y,pos.z) - R_EARTH;

    // draw
    ctx.clearRect(0,0,W,H);
    drawStars(now);
    drawEarth(sDir);
    drawOrbitPath(trail);
    drawCubeSat(pos, eclipsed);

    // fraction of light (0 in umbra, ~0.5 penombra, 1 luce)
    const dAx = Math.sqrt(dot(pos,pos) - Math.pow(dot(pos, sDir),2));
    const lightFrac = eclipsed ? Math.max(0, Math.min(1, (dAx - R_EARTH*0.75) / (R_EARTH*0.25))) : 1;
    updateHUD(el.a, el.e, alt, lightFrac);
  }
  requestAnimationFrame(loop);

  // Parallax stars already defined above
  function onResize(){
    const r=canvas.getBoundingClientRect(), dpr=window.devicePixelRatio||1;
    canvas.width = Math.max(640, Math.floor(r.width*dpr));
    canvas.height= Math.floor(canvas.width*9/16);
    W=canvas.width; H=canvas.height; cx=W/2; cy=H/2;
  }
  window.addEventListener('resize', onResize);
  onResize();
  syncUI();
})();
</script>
</body>
</html>
